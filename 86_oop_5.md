## 코드스피츠 86 - 5회차 (2020.02.05)
> 
### 1. OOP
4.js 지난주 코드분석..
binder -> viewmodel, viewmodel의 subject를 통해서 notify를 할 예정
target 이 viewModelSubject 의 this 를 상속하므로 viewModel을 받으려면 hook으로 받아서 진짜 타겟을 받아서 호출한다. 
> 층이 분리되면 레이어를 나누는 이슈가 항상 발생한다.

프로세서에게 위임해서 vm이 처리할 수 있도록 한다. 바인더에서 처리하는 방법, binder 에 프로세서를 끼워서 처리할 수 있도록 함.
프로세서 키가 vm의 키를 찾아내므로, 프로세서 등록에 따라 만드는데 viewModel 에 `styles,attiributes,properties` 키를 하드코딩 된 걸 제거하고 다른 속성을 가질 수 있도록 데이터 구조에 맞게 만들어야하지 처리기만 동적으로 해서는 안된다.

> 데이터 구조를 동적으로 바꾸는 과정이 필요하다. 데이터를 조금 자유스럽게 기술하게 만들자.
> 옵저버패턴에 잘 맞도록 파서를 만들어서 동적으로 getter, setter 를 생성하자.

`addProcessor` 즉, 바인더가 컬렉션을 갖게 되면, 배열의 역할이 더 무거워진다. 자신만의 프라이빗 코드를 외부에 노출하게 된다.

### 2. Dynamic Dataset
viewModel, constructor 에서 데이터가 트리의 깊이가 다른 데이터를 루프를 돌면서 비정형 그래프 탐색을 할 수 있어야한다. 
아래 2가지 문제를 같이 풀어야한다.
데이터의 구조적인 문제: 객체만을 구성하는 디자인 문제
반복문의 문제: 변수의 foreach 의 일반화의 문제

`this.define` 탑 레벨에 있는 배열이나 오브젝트가 아닐 경우엔 가능한데, 그 반대로 왔을 땐
진입점 함수와 루프 함수는 다르다. 재귀에 최적화된 함수이므로, 루프 함수를 쓴다.

1. ViewModel 이 아니면서 오브젝트를 스캔한다. 
Tip. Array polyfill 안하면 구형 브라우저에서 깨짐
2. v.forEach 타겟 k에 원소 인덱스와 값을 쓰면 다음 인덱스와 값을 보내준다. 원소가 배열이면 또 같은 반복을 한다.
3. `entries` 오브젝트의 사본을 만들어서 다시 참조해서 루프를 만든다.
4. 타겟 k에 따라 defineProperties 로 getter, setter 로 만들어진다.
5. properties 는 배열의 원소로 인지를 못해서, length 가 ie8 에선 나오지 않는다.

> JSON.stringfy 를 꼭 구현해보자
1. 루트로 부터 상대적인 경로를 "." 로 확장해서 다시 재귀를 돌면, 부모 키에 자기 자신을 가지고있다.
2. ViewModel.KEY 를 배열 안에서 부모의 키의 확장해서 새로 만든다. (depth에 따라 키가 결정된다)
3. termination (종결)부분은 else 로 넘어온 값들을 종결조건이 mendatory 를 쓰게 된다.
   if, else 는 경우를 확정 지은 거라 재귀가 일어나지 않는 종결점을 확실히 하자.
> 제어문은 optional 는 if 만 쓰는 경우.
> 재귀파서는 중첩된 json 형태를 계속 순회해서 그리는 방법을 구현하자.

결론: Viewmodel 에 속성을 주면 observing 할 수 있도록 역할이 축소화 된다. 일반적인 모델들이 nofity 가 가능한 일반화된 모델이 됨. OCP 가 결정, 미리 프로세서를 만들어 둔다.

`setProcessor` 바인더에 데코레이터 패턴(바인더의 도움없이 프로세서 세트를 만들 수 있음), 링크드리스트로 처리기를 다음번의 것만 알 수 있도록 할 수 있다. 소유하는것에 대한 격리를 할 수 있다. 컬렉션은 좀 더 무거움. 
제어 구문으로 루프를 하면, every, any, foreach 밖에 없지만 객체 만의 제어 구문을 구분하는 것이 가능하다! 

배열이 객체 컬렉션을 갖고 있으면, set 으로 할 수 있다. 컬렉션의 첫번째 중복값을 허용하지 않으면 set 을 써야한다. 
정말 배열안에 값 3이 여러번 쓰는 경우가 없다. 

배열이 아니라 객체가 원소만 있으면 set 이다. 단순 처리를 데이터만 제공하는 경우엔 binderItem 엔 행위 없이 값만 있으므로  값 객체이므로 값으로 식별되므로 render의 루프 정책에서도 값으로 식별될 수 있다. 

> 데코레이터 패턴은 프로세서는 행위를 갖고 컬렉션을 갖고 있는 객체는 링크드리스트로 풀어야한다. 
ex) `if(this.#next && vm.xx && vm.....)` 조건들이 분명히 추가될 것이므로.

> 인터페이스를 만들 때, 링크드리스트 후방참조 방식으로 만드는게 코드가 깔끔하진 않으므로 다른 참조 방법으로 만들어봐야한다.

> 마지막 구현체에 따라 안정성이 흔들릴 수 있다. 그러므로 안정화된 코드는 코어를 제어 역할을 넘길 수 있도록 제어 역전을 엄청해서 무거운 코어를 만들자. 성장하는 서비스는 제어역전 서비스가 어렵다. 

### 3. Template 
하드코딩을 없애고 뷰모델과 바인더가 플러그인 역할을 할 수 있도록 밑작업을 해둠

``` js
// 오브젝트 검증: undefined 에 대한 처리
const {
  name = err("no name")
} = vm.template;
```

DomScanner 를 바꿔서 template 이면, map 에 element 에 확인한다.
`el.parentElement?.removeChild(el)`

싱글톤 패턴으로 가능하다면, 무조건 클래스를 만들자. 
클래스를 만들어서 하나 만들면 1 또는 N 개로 쓸 수 있다. static 코드는 인스턴스를 만들땐, 무조건 클래스를 만드는게 나중에 유지보수가 좋다. 

클래스 싱글톤과 스태틱의 큰 차이점, 스태틱은 상속이 안된다. 인스턴스를 써야 객체지향의 혜택을 받을 수 있는 싱글톤 객체를 만드는게 우선이다.

쉴드 패턴: 쉴드 영역은 black list 와 white list 를 분리한다. 
검증 코드를 모두 분리해서 모든 변수가 안정화 되었을때만 가져와서 쓸 수 있도록 (balck list) throw, return 으로 처리한다. 
값을 검증을 할 필요가 없도록 하자. (white list) 순수한 제어로직만 가져올 수 있도록 한다.
검증되지 않은 데이터를 쓰고 있으면, `const WL = {template, data}` 로 선언해서 클렌징 코드를 연습하면서 시각적으로 잘보고 없어도 잘 보이도록 연습해서 쓰길 바람.

> 로직코드가 시작되기 전에 모든 검증을 끝내야한다. 코드 유지보수가 훨씬 쉽다. foreach 2번 돌려도 괜찮다.

li 의 바인더가 각각 template 엘리먼트를 분해해서 재귀적으로 그린다.
다중 템플릿을 메타 데이터를 처리할 수 있도록 만들고 기능을 확장할 수 있다.
바인더 입장에서 프로세서가 플러그인 형태..

스몰 코어를 만들고, 플러그인의 플러그인으로 확장해서 제어 접근을 할 수 있도록 만든다. 중앙을 둘러싼 위성들을 많이 만들어서 사용하자.
코드를 마이크로하게 보지 않고, 마이크로는 함수로 만들자. mock 데이터만 만들면 된다.
그러므로 매크로 하게 구조를 잡는 것이 중요하고 OCP 의 원칙을 지켜서 역할 분리를 하면 디버깅을 줄일 수 있다.
매크로는 예외 케이스, 순서가 잘못(상태가 외부에 노출 되었을때)되거나 데이터가 다르게 들어왔을때의 문제이다. 구조를 잘 짜야한다.

> 내 코드가 디버깅을 줄일 수 있는건 내가 제어할 수 있는 제어권을 벗어난 것이고, 격리를 잘해둬야 로그만으로 확인 할 수 있다.


