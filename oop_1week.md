## 코드스피츠 86 - 1회차 (2020.01.08) 
 ### 1. 객체지향
  - 값의 특징은 사용한다는 건 복사해서 만든다는 것
  - 안전한가? 상태관리로써 안전한게 아니라서 계속 불변하는 값을 만들어내서 안전해보임
  > 값을 사용하지 않는 방법
  > 만든거까지만 구동을 할 수 있도록 나머지는 실패하도록 유도할 수 있다. 메시지로 위임이 가능하기 때문이다.
 
 ### 2. Polymorphism
  - 확장된 클래스는 확장된 대상으로 대체할 수 있다 => `대체가능성`
  ex) hardWorker의 부분집합이 Worker 이므로 대체할 수 있다. 
  - 생성시점의 타입이 자기 자신을 유지한다 => `내적일관성`
  ex) worker - pint() 를 실행할때, hardworker 의 print를 실행한다. 
 
 ### 3. Prototype
  - __proto__ 는 생성자에서 만들어진다.
  - 자바스크립트는 대체 가능성과 내적 일관성을 유지할 수 있는 방법이다.
 
 ### 4. 위장과 은닉
  - 객체를 사용한다 것은 상태를 외부에 보여주지 않는다. (속성이 private 인지 확인한다.) => `데이터 은닉`
  - 메소드가 바깥에서 모두 추상화로 인식해야한다. 외부에 제공하지 않는다. => `기능의 캡슐화`
  ex) ATM 카드넣으면 돈 줘! (신용확인->잔고확인->ATM 외부에 모두 노출하지 않는다. 녹음되어있는 돈 세는 소리.. 등)
  ex) 속성만 은닉하는건 잘못된거다. (setter, getter) 
  - 메모리로 이용되야하는데 객체를 값으로 쓰면 값 컨텍스트를 노출하게 된다.
  - 값 컨텍스트로 오염을 시키면 객체지향은 깨지고 무너진다.
  > setAge 를 쓸때면 외부에서 Age 를 쓰게끔 열어둔건데 이건 객체가 아니다. 
  > 연역적, 귀납적 사고를 반복해서 추론능력을 길러야하고 합리적 사고를 쌓아야한다. 
  > 공감적, 경험적이면 빠르면 5-7년..개인적인 공감코드가 들어갈 필요가 없다는 걸 빨리 인정해보자. 
  > 개인을 대입하지말고 논리적으로 생각하는 걸 반복 훈련해야한다. 훈련하면 된다.

  - 격리벽에서 차단을 해서 정상 복구를 하거나 내결함성이 깨지고 사방에서의 오류를 막아준다.

 ### 5. Solid
  - Single Responsiblity : 코드를 고쳐야하는 경우는 하나 뿐이다.
  ex) 탄산총
  - Open-Closed : extends 와 implements 클래스를 만들어서 문제를 푼다. interface 를 상속받아서 해결을 풀자.
  > 문제들의 공통점을 찾아서 해결하되, 다른 문제와 연결하지 말자. 
  - Liskov : 업캐스팅과 다운캐스팅을 이용해서 사용한다. 
  ex) 추상 클래스를 업캐스팅 할 수 있게. (추상층: 생물, 기능: 다리이동)
  - ISP : 인터페이스를 분리해서 사용한다.  
  > (소유)위임을 사용한 인터페이스 => 서로 보완이 되니깐 객체별로 상대를 할 수 있도록 구현한다.
  > 인터페이스 여러개 가져와서 오버라이드 해서 구현한다.
  - Dependency Inversion : 의존성을 낮추는 방법
   - 의존성 역전의 법칙: 항상 추상 인터페이스를 만들고 다운 캐스팅을 하지 마라. 
   - DI 의존성 주입 
 
 ### 6. DI 
 - 의존성 역전의 법칙: OCP, DIP 를 지킬 수 있도록 충분한 의도를 표현해야한다.
 - OCP 가 안되면 DIP 가 될 수 없다.
 
 ### 7. IOC
  - 제어 역전 법칙: Control Flow 는 흐름을 점프를 하거나 돌리거나 흐름 제어. 비동기와 스레드를 모두 제어를 하는거고.
  - 역으로 대체해주겠다라는 말이고 위임과 유사하다.
  ex) 뛰어난 운전자와 같이 있으면 나도 돈과 목적지를 얘기를 하더라도 운전을 잘하고 길을 잘 알게 된다.
  - 제어 흐름에서 상태를 흐름에 따라 갱신한다.  
  > 격리 보안을 세우로 변화에 대한 격리를 하기 위해서 OOP 의 이유.
  > 메서드 줄을 10줄로 제한하는 이유는 제어문의 알고리즘을 짜는데 한계가 있다.